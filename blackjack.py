# test double up, test split (cas aces) + Opti structure de donnÃ©es
from __future__ import print_function
import os
import time
from copy import deepcopy
from math import ceil
import random
from threading import Thread
class Game(Thread):
    def __init__(self, iters, display):
        Thread.__init__(self)
        self.display = display
        self.record = 0.
        self.iters = iters
        self.done = 0
        self.taskdone = False
    def play(self):
        for iter in range(self.iters):
            deck = Deck()
            self.pcards = [deck.draw(), deck.draw()]
            self.dcards = [deck.draw()]
            #self.pcards = [deck.pick(1), deck.pick(2)]
            #self.dcards = [deck.pick(6)]
            self.ddib = self.eval_dealer(self.dcards, deck.cards, [0] * 7, 1.)
            current = self.ev(self.pcards, deck.cards)
            self.record += current
            self.done += 1
            if not iter % 50 and self.display:
                if iter:
                    os.system('cls' if os.name=='nt' else 'clear')
                    print("{} iterations done ({}%)".format(iter, round(float(iter)/self.iters,4)*100))
                    print("Elapsed time: {}s".format(timer.count))
                    print("Current average EV = {}%".format(round(100 * self.record / iter, 2)), end = '')
                else:
                    print('Running...')
            
            # self.evstand = self.ev(self.pcards, deck.cards)
            # print(self.dcards, self.pcards)
            # print([round(i, 4) for i in self.ddib])
            # print(self.evstand)
            # print(current)
        self.taskdone = True
            
    def eval_dealer(self, hand, deck, toreturn, prob):
        score = self.score(hand)
        if score > 16 or not score:
            if score == 0:
                toreturn[5] += prob
            elif score < 22:
                toreturn[score - 17] += prob
            else:
                toreturn[6] += prob
        else:
            for value, count in enumerate(deck):
                if count:
                    ndeck = [_ for _ in deck]
                    ndeck[value] -= 1
                    nhand = hand + [value]
                    toreturn = self.eval_dealer(nhand, ndeck, toreturn, prob * count / (sum(deck)))
        return toreturn
        
    def score(self, cards):
        nbAces = cards.count(0)
        res = sum(cards) + len(cards) + nbAces * 10
        if res == 21 and len(cards) == 2:
            return 0
        for _ in range(nbAces):
            if res > 21:
                res -= 10
        return res

    def evd(self, score, evD):
        if score > 21:
            return 0
        if score == 0:
            return 1.5*(1 - evD[5])
        res = evD[6] - evD[5]
        index = max([score - 17, -1])
        res += sum(evD[:index if index != -1 else 0]) - sum(evD[index+1:5])
        return res

    def ev(self, hand, deck):
        cur_ev = self.evd(self.score(hand), self.ddib)
        ev_draw = 0
        tcount = float(sum(deck))
        for value, count in enumerate(deck):
            if count:
                nhand = hand + [value]
                score = self.score(nhand)
                if score > 21:
                    ev_draw -= count
                else:
                    ndeck = [_ for _ in deck]
                    ndeck[value] -= 1
                    tmp_ev = self.evd(self.score(nhand), self.ddib)
                    if not sum(nhand) + len(nhand) < self.score(nhand) and score > 16:
                        ev_draw += count * tmp_ev
                    else:
                        ev_draw += count * max([tmp_ev, self.ev(nhand, ndeck)])
        return max(cur_ev, ev_draw/(tcount))
    
class Deck:
    def __init__(self):
        self.NBDECKS = 8
        self.cards = [4 * self.NBDECKS] * 9 + [16 * self.NBDECKS]

    def draw(self):
        a = random.randint(0,sum(self.cards))
        for i in range(10):
            if sum(self.cards[:i+1]) >= a:
                self.cards[i] -= 1
                return i
    
    def pick(self, value):
        self.cards[value - 1] -= 1
        return value - 1

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0.
        self.hastorun = True
    def run(self):
        while self.hastorun:
            time.sleep(.2)
            self.count += .2

def runwild(iters):
    game = Game(iters, True)
    game.play()
    os.system('cls' if os.name=='nt' else 'clear')
    print("{} iterations done in {}s\nAverage EV = {}%".format(iters, timer.count, round(100 * game.record / iters, 2)))

timer = Timer()
timer.start()
runwild(1000)
