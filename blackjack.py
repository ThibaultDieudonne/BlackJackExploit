# test double up, test split (cas aces)
# sauvegarder les parametres de evd deja evalues
# remettre ev en fonction de la profondeur (checker commits) + verifier si pas plus rapide en stockant les listes
# 1-sum pour res[7]
# playsingle
import os
import time
import random
import operator
import string
import numpy as np
from threading import Thread
class Game():
    '''Handle game simulation'''
    def __init__(self):
        '''class inits'''
        # timer init
        self.timer = Timer()
        self.timer.is_daemon = True
        self.timer.start()
        # fast calculation graphs generating
        Graphs = [Graph(i)for i in range(10)]
        self.graphs = [gr.construct() for gr in Graphs]
        
    def play(self, cards):
        '''returns average ev of {pcard, x, dcard}'''
        deck = Deck()
        (self.card1, self.dcard) = cards
        self.evds = []
        self.hands = []
        self.pcards = [deck.pick(self.card1)]
        self.dcards = [deck.pick(self.dcard)]
        self.ddib = self.eval_dealer(deck.cards)
        sco = score(self.pcards)
        return self.ev(self.pcards, deck.cards, self.evd(sco, self.ddib)) if sco else 1.5 * (1 - self.ddib[5])
    
    def evd(self, sco, ddib):
        '''returns ev of player's score against dealer's score distribution'''
        if sco > 21:
            return 0
        if sco == 0:
            return 1.5*(1 - ddib[5])
        toreturn = ddib[6] - ddib[5]
        index = max([sco - 17, -1])
        toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
        return toreturn

    def ev(self, phand, deck, cur_ev):
        '''recursive function evaluating player's ev for each possible action''' 
        ev_draw = 0
        tcount = float(sum(deck))
        # simulate each possible draw
        for value, count in enumerate(deck):
            if count:
                # evaluating new score
                nhand = phand + [value]
                sco = score(nhand)
                ndeck = [_ for _ in deck]
                ndeck[value] -= 1
                # handle 'too many' 
                if sco > 21:
                    ev_draw -= count
                else:
                    lhand = len(nhand)
                    shand = sorted(nhand[1:])
                    strhand = string.joinfields(map(str, shand), "")
                    # considering ev({x0, x1, x2, ..., xi}) == ev({x0, permutations})
                    # access ev if stored
                    if shand != nhand[1:]:
                        ev_draw += count * self.evds[self.hands.index(strhand)]
                    else:
                        # handle 'must draw in any case' (skips ev calculation)
                        if sco < 12 and sco > 0:
                            tmp_ev = self.ev(nhand, ndeck, cur_ev)
                            ev_draw += count * tmp_ev
                        else:
                            # calculationg dealer's score distribution on more-or-less significant hands
                            if lhand < 5:
                                self.ddib = self.eval_dealer(ndeck)
                            # calculating ev
                            tmp_ev = self.evd(sco, self.ddib)
                            # going recursive
                            if sum(nhand) + lhand != sco or (sco < 18 and sco) :
                                tmp_ev = max([tmp_ev, self.ev(nhand, ndeck, tmp_ev)])
                            # weigting found ev
                            ev_draw += count * tmp_ev
                        # saving result
                        if lhand > 2:
                            self.hands.append(strhand)
                            self.evds.append(tmp_ev)
        return max(cur_ev, ev_draw/(tcount))
        
    def eval_dealer(self, deck):
        '''function making dealer's score distribution based on deck composition'''
        decksum = sum(deck)
        deck = map(float, deck)
        self.prods = []
        tmp = 1
        for i in range(11):
            tmp *= decksum - i
            self.prods.append(tmp)
        self.probs = [[1., deck[i]] for i in range(10)]
        for index, mcount in [(0,10), (1,8), (2,5), (3,4), (4,3), (5,3), (6,3), (7,2), (8,2), (9,2)]:
            tmp = float(deck[index])
            for i in range(1,mcount):
                tmp *= deck[index] - i
                self.probs[index].append(tmp)

        return [sum(map(self.f, issue))for issue in self.graphs[self.dcards[0]]]
        
    def f(self, x):
        return product(map(self.g, list(enumerate(x[:-1]))))*x[-1]/(self.prods[sum(x[:-1])-1])
        
    def g(self, x): # tester de ne plus passer par probs => - enumerate (eventuellement prods)
        return self.probs[x[0]][x[1]]
        
class Graph():
    def __init__(self, card):
        self.deck = Deck()
        self.hands = [[]for _ in range(7)]
        self.ans = [[]for _ in range(7)]
        self.dcard = self.deck.pick(card)
        
    def construct(self):
        inp = [0 for _ in range(10)]
        inp[self.dcard] += 1
        self.construct_rec(inp)
        fingra = []
        for ir,r in enumerate(self.ans):
            tmparray = []
            for d in r:
                if d:
                    tmparray.append(d)
            fingra.append(np.array(r))
        return fingra
        
    def construct_rec(self, dhand):
        shand = [_ for _ in dhand]
        shand[self.dcard] -= 1
        sco = score2(dhand)
        if sco > 16 or not sco:
            if sco == 0:
                pindex = 5
            elif sco < 22:
                pindex = sco - 17
            else:
                pindex = 6
            try:
                index = self.hands[pindex].index(shand)
                self.ans[pindex][index][-1] += 1
            except:
                self.hands[pindex].append(shand)
                self.ans[pindex].append(shand + [1])
        else:
            for value in range(10):
                nhand = [_ for _ in dhand]
                nhand[value] += 1
                self.construct_rec(nhand)
        return None
        
                
class Deck:
    def __init__(self):
        self.cards = [32, 32, 32, 32, 32, 32, 32, 32, 32, 128]

    def draw(self):
        a = random.randint(0,sum(self.cards))
        for i in range(10):
            if sum(self.cards[:i+1]) >= a:
                self.cards[i] -= 1
                return i
    
    def pick(self, value):
        self.cards[value] -= 1
        return value

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0
        self.hastorun = True
    def run(self):
        cnames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T']
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, self.done))
                print('Evaluating {}x vs {} {}'.format(cnames[game.card1], cnames[game.dcard], '.' * (self.count % 4)))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1

def cls():
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')
    
def product(iterable):
        return reduce(operator.mul, iterable, 1)
        
def score(cards):
    nbAces = cards.count(0)
    toreturn = sum(cards) + len(cards)
    if cards == [0, 9] or cards == [9, 0]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn
    
def score2(hand):
    nbAces = hand[0]
    toreturn = sum(hand)
    for i,j in enumerate(hand):
        toreturn += i*j
    if hand == [1,0,0,0,0,0,0,0,0,1]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn

def run():
    globals()['game'] = Game()
    deck = Deck()
    record = 0.
    hands = []
    probs = []
    s = float(sum(deck.cards))
    for c1 in range(10):
        p1 = deck.cards[c1]
        for c2 in range(10):
            if c1 == c2:
                p2 = p1 - 1
            else:
                p2 = deck.cards[c2]
            probs.append(p1 * p2)
            hands.append([c1, c2])
    for index in range(len(hands)):
        record += game.play(hands[index]) * probs[index]
        game.timer.done += 1
    game.timer.hastorun = False
    cls()
    print("Every case evaluated in {}s\nGlobal EV = {}%".format(game.timer.count, round(100 * record / (s * (s - 1)), 6)))
    
run()

