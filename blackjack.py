# test double up, test split (cas aces)
# evaluer plus couteux en dernier par 1 - reste
import os
import time
import random
import operator
from threading import Thread
class Game():
    def __init__(self):
        self.timer = Timer()
        self.timer.is_daemon = True
        self.timer.start()
        Graphs = [Graph(i)for i in range(10)]
        self.graphs = [g.construct() for g in Graphs]
        
    def play(self, deck, cards):
        (self.card1, self.card2, self.dcard) = cards
        self.evds = []
        self.hands = []
        self.pcards = [deck.pick(self.card1), deck.pick(self.card2)]
        self.dcards = [deck.pick(self.dcard)]
        self.ddib = self.eval_dealer(deck.cards)
        sco = score(self.pcards)
        return self.ev(self.pcards, deck.cards, self.evd(sco, self.ddib)) if sco else 1.5 * (1 - self.ddib[5])

    def evd(self, sco, ddib):
        if sco > 21:
            return 0
        if sco == 0:
            return 1.5*(1 - ddib[5])
        toreturn = ddib[6] - ddib[5]
        index = max([sco - 17, -1])
        toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
        return toreturn

    def ev(self, phand, deck, cur_ev):
        ev_draw = 0
        tcount = float(sum(deck))
        for value, count in enumerate(deck):
            if count:
                nhand = sorted(phand + [value])
                lhand = len(nhand)
                strhand = ''.join(map(str, nhand)).zfill(lhand)
                try:
                    ev_draw += count * self.evds[lhand - 1][self.hands[lhand - 1].index(strhand)]
                except:
                    sco = score(nhand)
                    if sco > 21:
                        ev_draw -= count
                    else:
                        ndeck = [_ for _ in deck]
                        ndeck[value] -= 1
                        tmp_ev = self.evd(sco, self.eval_dealer(ndeck))
                        # tmp_ev = self.evd(sco, self.ddib)
                        if sum(nhand) + len(nhand) != sco or sco < 18:
                            tmp_ev = max([tmp_ev, self.ev(nhand, ndeck, tmp_ev)])
                        ev_draw += count * tmp_ev
                        while len(self.hands) < lhand:
                            self.hands.append([])
                            self.evds.append([])
                        self.hands[lhand - 1].append(strhand)
                        self.evds[lhand -1].append(tmp_ev)
        return max(cur_ev, ev_draw/(tcount))
        
    def eval_dealer(self, deck):
        ddib = []
        for index in range(7):
            sco = 0.
            for deep, endnodes in enumerate(self.graphs[self.dcards[0]][index]):
                tosum = []
                for endnode in endnodes:
                    cards = endnode[:-1]
                    tomult = []
                    for card in set(cards):
                        if card == self.dcards[0]:
                            tomult.extend([deck[card] - i for i in range(cards.count(card) - 1)])
                        else:
                            tomult.extend([deck[card] - i for i in range(cards.count(card))])
                    tomult.append(endnode[-1])
                    tosum.append(product(tomult))
                sco += sum(tosum) / float(product([sum(deck) - i for i in range(deep + 1)]))
            ddib.append(sco)
        return ddib
        
class Graph():
    def __init__(self, card):
        self.deck = Deck()
        self.hands = [[],[],[],[],[],[],[]]
        self.occ = [[],[],[],[],[],[],[]]
        self.ans = [[],[],[],[],[],[],[]]
        self.dcard = [self.deck.pick(card)]
        
    def construct(self):
        self.construct_rec(self.dcard)
        return self.ans
        
        
    def construct_rec(self, dhand):
        dhand = sorted(dhand)
        sco = score(dhand)
        if sco > 16 or not sco:
            lhand = len(dhand) - 2
            if sco == 0:
                pindex = 5
            elif sco < 22:
                pindex = sco - 17
            else:
                pindex = 6
            self.addempty(pindex, lhand)
            try:
                index = self.hands[pindex][lhand].index(dhand)
                self.occ[pindex][lhand][index] += 1
                self.ans[pindex][lhand][index][-1] += 1
            except:
                self.hands[pindex][lhand].append(dhand)
                self.occ[pindex][lhand].append(1)
                self.ans[pindex][lhand].append(dhand + [1])
        else:
            for value in range(10):
                nhand = dhand + [value]
                self.construct_rec(nhand)
        return None
    def addempty(self, index, lhand):
        while len(self.hands[index]) < lhand + 1:
            self.hands[index].append([])
            self.occ[index].append([])
            self.ans[index].append([])
                
class Deck:
    def __init__(self):
        self.cards = [32, 32, 32, 32, 32, 32, 32, 32, 32, 128]

    def draw(self):
        a = random.randint(0,sum(self.cards))
        for i in range(10):
            if sum(self.cards[:i+1]) >= a:
                self.cards[i] -= 1
                return i
    
    def pick(self, value):
        self.cards[value] -= 1
        return value

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0.
        self.hastorun = True
    def run(self):
        cnames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T']
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, round(self.done * 10 / 55, 2)))
                print('Evaluating {}{} vs {} {}'.format(cnames[game.card1], cnames[game.card2], cnames[game.dcard], '.' * (self.count % 4)))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1

def cls():
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')
    
def product(iterable):
        return reduce(operator.mul, iterable, 1)
        
def score(cards):
    nbAces = cards.count(0)
    toreturn = sum(cards) + len(cards)
    if cards == [0, 9] or cards == [9, 0]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn
        
def run():
    globals()['game'] = Game()
    deck = Deck()
    record = 0.
    hands = []
    probs = []
    s = float(sum(deck.cards))
    for c1 in range(10):
        p1 = deck.cards[c1]
        for c2 in range(10):
            if c1 == c2:
                p2 = p1 - 1
            else:
                p2 = deck.cards[c2]
            for c3 in range(c1, 10):
                if c2 == c3:
                    if c1 == c2:
                        p3 = p2 - 1
                    else:
                        p3 = 2 * (p2 - 1)
                elif c1 == c3:
                    p3 = p1 - 1
                else:
                    p3 = 2 * deck.cards[c3]
                probs.append(p1 * p2 * p3)
                hands.append([c1, c3, c2])
    for index in range(len(hands)):
        record += game.play(Deck(), hands[index]) * probs[index]
        game.timer.done += 1
    game.timer.hastorun = False
    cls()
    print("Every case evaluated in {}s\nGlobal EV = {}%".format(game.timer.count, round(100 * record / (s * (s - 1) * (s - 2)), 6)))

def singletest(card1, card2, dcard, iters = 1):
    globals()['game'] = Game()
    for i in range(iters):
        toreturn = game.play(Deck(), (card1 - 1, card2 - 1, dcard - 1))
    game.timer.hastorun = False
    print("EV = {}%".format(round(100 * toreturn, 6)))
run()

#singletest(8,8,10)