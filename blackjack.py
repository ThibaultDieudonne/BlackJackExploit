# test double up, test split
# playsingle

import os
import sys
import time
import pickle
import inspect
from threading import Thread
_filepath = os.path.realpath(
            os.path.abspath(
                os.path.split(
                    inspect.getfile(
                        inspect.currentframe()))[0]))

class Ev():
    
    '''handle case enumeration with memory'''
    __slots__ = 'evds', 'hands', 'ddib', 'doubles', 'ev_doubles', 'card1', 'dcard', 'deck'
    
    def __init__(self, cards):
        '''class inits'''
        (self.card1, self.dcard) = cards
        self.deck = [_ for _ in _deck]
        self.deck[self.card1] -= 1
        self.deck[self.dcard] -= 1
        self.evds = [[]for _ in range(16)]
        self.hands = [[]for _ in range(16)]
        self.doubles = []
        self.ev_doubles = []
        self.ddib = eval_dealer(self.deck, self.dcard)

    def ev(self, phand, deck, cur_ev):
        # split must be calculated at depth 1 and be a single draw for aces
        '''recursive function evaluating player's ev for each possible action'''
        # simulate each possible draw
        ev_draw = 0
        lhand = len(phand) + 1
        total_count = float(sum(deck))
        if lhand == 3:
            ev_double = 0
        for value, count in enumerate(deck):
            if count:
                # evaluating new score
                nhand = phand + [value]
                sco = score(nhand)
                ndeck = [_ for _ in deck]
                ndeck[value] -= 1
                # handle 'too many' 
                if sco > 21:
                    ev_draw -= count
                    if lhand == 3:
                        ev_double -= count
                else:
                    shand = sorted(nhand[1:])
                    # considering ev({x0, x1, x2, ..., xi}) == ev({x0, permutations(x1:xi)})
                    # access ev if stored 
                    try:
                        ev_draw += count * self.evds[lhand - 1][self.hands[lhand - 1].index(shand)]
                        if lhand == 3:
                            ev_double += count * self.ev_doubles[self.doubles.index(shand)]
                    except:
                        # calculationg dealer's score distribution on more-or-less significant hands
                        if lhand < 4:
                            self.ddib = eval_dealer(ndeck, self.dcard)
                        # calculating ev
                        tmp_ev = evd(sco, self.ddib)
                        # saving ev of two cards hands
                        if lhand == 3:
                            ev_double += count * tmp_ev
                            self.doubles.append(shand)
                            self.ev_doubles.append(tmp_ev)
                        # going recursive
                        if sco < 19 and sco:
                            tmp_ev = max([tmp_ev, self.ev(nhand, ndeck, tmp_ev)])
                        # weigting found ev
                        ev_draw += count * tmp_ev
                        # saving result
                        if lhand > 2:
                            self.hands[lhand - 1].append(shand)
                            self.evds[lhand - 1].append(tmp_ev)
        if lhand == 3:
            return max(cur_ev, ev_draw/total_count, 2*ev_double/total_count)
        return max(cur_ev, ev_draw/total_count)
            

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0
        self.hastorun = True
    def run(self):
        cnames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T']
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, self.done))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1

def cls():
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')
          
def score(cards):
    nbAces = cards.count(0)
    toreturn = sum(cards) + len(cards)
    if cards == [0, 9] or cards == [9, 0]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn
    
def eval_dealer(deck, dcard):
    '''function making dealer's score distribution based on deck composition'''
    ddib = []
    dsumcalcs = _PRECALC2[sum(deck) - 32]
    for index in _R6:
        sco = 0.
        for deep, endnodes in enumerate(_GRAPHS[dcard][index]):
            tosum = 0
            for endnode in endnodes:
                cards = endnode[:-1]
                tomult = endnode[-1]
                for card, count in cards:
                    if count:
                        remaining = deck[card]
                        tomult *= _PRECALC[count - 1][remaining - 1] 
                tosum += tomult
            sco += tosum / dsumcalcs[deep]
        ddib.append(sco)
    return ddib + [1 - sum(ddib)]
        
def evd(sco, ddib):
    '''returns ev of player's score against dealer's score distribution'''
    if sco > 21:
        return 0
    if sco == 0:
        return 1.5 * (1 - ddib[5])
    toreturn = ddib[6] - ddib[5]
    index = max([sco - 17, -1])
    toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
    return toreturn
        
    
if __name__ == '__main__':
    with open(os.path.join(_filepath, 'GRAPHS'), 'rb') as fp:
        _GRAPHS = pickle.load(fp)
    with open(os.path.join(_filepath, 'PRECALC'), 'rb') as fp:
        _PRECALC = pickle.load(fp)
    with open(os.path.join(_filepath, 'PRECALC2'), 'rb') as fp:
        _PRECALC2 = pickle.load(fp)
    _R6 = [0,1,2,3,4,5]
    _timer = Timer()
    _timer.is_daemon = True
    _timer.start()
    _deck = [32, 32, 32, 32, 32, 32, 32, 32, 32, 128] # sys.argv[:10]
    record = 0.
    hands = []
    probs = []
    s = float(sum(_deck))
    for c1 in range(10):
        p1 = _deck[c1]
        for c2 in range(10):
            if c1 == c2:
                p2 = p1 - 1
            else:
                p2 = _deck[c2]
            probs.append(p1 * p2)
            hands.append([c1, c2])
    for index in range(len(hands)):
        calc = Ev(hands[index])
        record += calc.ev([calc.card1], calc.deck, evd(score([calc.card1]), calc.ddib)) * probs[index]
        _timer.done += 1
    _timer.hastorun = False
    cls()
    print("Every case evaluated in {}s\nGlobal EV = {}%".format(_timer.count, round(100 * record / (s * (s - 1)), 6)))
    sys.exit()
