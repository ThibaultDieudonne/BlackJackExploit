import os
import sys
import time
import pickle
import importlib
import inspect
from threading import Thread
_filepath = os.path.realpath(
            os.path.abspath(
                os.path.split(
                    inspect.getfile(
                        inspect.currentframe()))[0]))
    
    
# import static
sys.path.append(_filepath)
importlib.import_module('load_static')
from load_static import _GRAPHS, _PRECALC, _PRECALC2, _R6
    
class FastEval():
    
    '''handle solving with memory for efficiency'''
    __slots__ = 'evds', 'hands', 'ddib', 'doubles', 'ev_doubles', 'cards', 'dcard', 'deck', 'depth', 'playsingle', 'inisize'
    
    def __init__(self, cards, deck, after_dealt, depth, playsingle = False, inisize = 0):
        '''class inits'''
        self.depth = depth
        self.playsingle = playsingle
        self.inisize = inisize
        self.dcard = cards[-1]
        self.cards = cards[:-1]
        if after_dealt:
            self.deck = deck
        else:
            self.deck = [_ for _ in deck]
            for card in cards:
                self.deck[card] -= 1
        self.evds = [[]for _ in range(16)]
        self.hands = [[]for _ in range(16)]
        self.doubles = []
        self.ev_doubles = []
        self.ddib = eval_dealer(self.deck, self.dcard)

    def ev(self, phand, deck, cur_ev, splits = 0):
        '''recursive function evaluating player's ev for each possible action'''
        ev_draw = 0
        lhand = len(phand) + 1
        total_count = float(sum(deck))
        if lhand == 3:
            ev_double = 0
            ev_split = -2
            if phand[0] == phand[1] and ((splits == 1 and phand[0]) or not splits):
                calc_split = FastEval([phand[0], self.dcard], deck, True, self.depth = depth)
                ev_split = 2 * calc_split.ev([phand[0]], calc_split.deck, -1, splits + 1)
        for value, count in enumerate(deck):
            # evaluating new score
            nhand = phand + [value]
            sco = score(nhand)
            ndeck = [_ for _ in deck]
            ndeck[value] -= 1
            # handle 'too many' 
            if sco > 21:
                ev_draw -= count
                if lhand == 3:
                    ev_double -= count
            else:
                shand = sorted(nhand[1:])
                # considering ev({x0, x1, x2, ..., xi}) == ev({x0, permutations(x1:xi)})
                # access ev if stored 
                try:
                    ev_draw += count * self.evds[lhand - 1][self.hands[lhand - 1].index(shand)]
                    if lhand == 3:
                        ev_double += count * self.ev_doubles[self.doubles.index(shand)]
                except:
                    # calculationg dealer's score distribution on more-or-less significant hands
                    if lhand < self.depth:
                        self.ddib = eval_dealer(ndeck, self.dcard)
                    # calculating ev
                    tmp_ev = evd(sco, self.ddib, splits)
                    # saving ev of two cards hands in order to access in ev_doubles later
                    if lhand == 3:
                        ev_double += count * tmp_ev
                        self.doubles.append(shand)
                        self.ev_doubles.append(tmp_ev)
                    # going recursive
                    if ((sco < 19 and sco) or (lhand == 2 and nhand[0] == nhand[1])) and (not splits or phand[0]):
                        tmp_ev = max([tmp_ev, self.ev(nhand, ndeck, tmp_ev, splits)])
                    # weigting found ev
                    ev_draw += count * tmp_ev
                    # saving result
                    if lhand > 2:
                        self.hands[lhand - 1].append(shand)
                        self.evds[lhand - 1].append(tmp_ev)
        if self.playsingle and lhand == self.inisize:
            if lhand == 3:
                return 'Stand: {}\nDraw: {}\nDouble: {}\nSplit: {}\nSurrender: {}'.format(cur_ev, ev_draw/total_count, 2 * ev_double/total_count, ev_split, -.5)
            return 'Stand: {}\nDraw: {}'.format(cur_ev, ev_draw/total_count)
        if lhand == 3:
            return max(cur_ev, ev_draw/total_count, 2 * ev_double/total_count, ev_split)
        return max(cur_ev, ev_draw/total_count)
            

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0
        self.hastorun = True
    def run(self):
        cnames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T']
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, self.done))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1

def cls():
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')
          
def score(cards):
    nbAces = cards.count(0)
    toreturn = sum(cards) + len(cards)
    if cards == [0, 9] or cards == [9, 0]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn
    
def eval_dealer(deck, dcard):
    '''function making dealer's score distribution based on deck composition'''
    ddib = []
    dsumcalcs = _PRECALC2[sum(deck) - 32]
    for index in _R6:
        sco = 0.
        for deep, endnodes in enumerate(_GRAPHS[dcard][index]):
            tosum = 0
            for endnode in endnodes:
                cards = endnode[:-1]
                tomult = endnode[-1]
                for card, count in cards:
                    if count:
                        remaining = deck[card]
                        tomult *= _PRECALC[count - 1][remaining - 1] 
                tosum += tomult
            sco += tosum / dsumcalcs[deep]
        ddib.append(sco)
    return ddib + [1 - sum(ddib)]
        
def evd(sco, ddib, splits):
    '''returns ev of player's score against dealer's score distribution'''
    if sco > 21:
        return 0
    if sco == 0:
        if splits:
            return 1 - ddib[5]
        else:
            return 1.5 * (1 - ddib[5])
    toreturn = ddib[6] - ddib[5]
    index = max([sco - 17, -1])
    toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
    return toreturn
