import os
import time
from threading import Thread

from load_static import _GRAPHS, _PRECALC, _PRECALC2, _R6

'''calculations maker'''

class FastEval():

    '''handle solving with memory for efficiency'''

    __slots__ = ['evs',
                 'hds',
                 'ddib',
                 'hdds',
                 'evsd',
                 'cards',
                 'dcard',
                 'deck',
                 'depth',
                 'psing',
                 'isize']

    def __init__(self, cards, deck, after_dealt, depth, psing=False, isize=0):
        '''class inits'''
        self.depth = depth
        self.psing = psing
        self.isize = isize
        self.dcard = cards[-1]
        self.cards = cards[:-1]
        self.deck = [_ for _ in deck]
        if not after_dealt:
            for card in cards:
                self.deck[card] -= 1
        self.hds = [[]for _ in range(16)]  # saved hands
        self.evs = [[]for _ in range(16)]  # saved expval
        self.hdds = []  # saved doubled hands
        self.evsd = []  # saved double expval
        self.ddib = eval_dealer(self.deck, self.dcard)

    def expval(self, phand, deck, cur_ev, splits=0):
        '''recursive function evaluating player's expval for each possible action'''
        ev_draw = 0
        lhd = len(phand) + 1
        total_count = float(sum(deck))
        if lhd == 3:
            ev_double = 0
            ev_split = -2
            if phand[0] == phand[1] and not splits:
                # and ((splits == 1 and phand[0]) or not splits): => resplit EV
                calc_split = FastEval(
                    [phand[0],
                     self.dcard],
                    deck,
                    True,
                    self.depth)
                ev_split = 2 * calc_split.expval(
                    [phand[0]],
                    calc_split.deck,
                    evd(score(calc_split.cards), calc_split.ddib, 1),
                    splits + 1)
        for value, count in enumerate(deck):
            # evaluating new score
            nhd = phand + [value]
            sco = score(nhd)
            ndeck = [_ for _ in deck]
            ndeck[value] -= 1
            # handle 'too many'
            if sco > 21:
                ev_draw -= count
                if lhd == 3:
                    ev_double -= count
            else:
                shd = sorted(nhd[1:])
                # access expval if stored
                try:
                    ev_draw += count * self.evs[lhd-1][self.hds[lhd-1].index(shd)]
                    if lhd == 3:
                        ev_double += count * self.evsd[self.hdds.index(shd)]
                except:
                    # calculationg dealer's scores probability distribution
                    if lhd < self.depth:
                        self.ddib = eval_dealer(ndeck, self.dcard)
                    # calculating expval
                    tmp_ev = evd(sco, self.ddib, splits)
                    # saving expval of two cards hds in order to access in evsd later
                    if lhd == 3:
                        ev_double += count * tmp_ev
                        self.hdds.append(shd)
                        self.evsd.append(tmp_ev)
                    # going recursive
                    subcond = (sco < 19 and sco) or (
                        lhd == 2 and nhd[0] == nhd[1])
                    if subcond and (not splits or phand[0]):
                        tmp_ev = max([
                            tmp_ev,
                            self.expval(nhd, ndeck, tmp_ev, splits)])
                    # weigting found expval
                    ev_draw += count * tmp_ev
                    # saving result
                    if lhd > 2:
                        self.hds[lhd - 1].append(shd)
                        self.evs[lhd - 1].append(tmp_ev)
        # dictionnary return for playsingle
        if self.psing and lhd == self.isize and not splits:
            toreturn = {'Stand': cur_ev, 'Hit': ev_draw/total_count}
            if lhd == 3:
                toreturn['Double'] = 2 * ev_double/total_count
                if ev_split != -2:
                    toreturn['Split'] = ev_split
            return toreturn
        # returning best expval
        if lhd == 3:
            if splits:
                return max(cur_ev, ev_draw/total_count, ev_split)
            else:
                return max(
                    cur_ev,
                    ev_draw/total_count,
                    2 * ev_double/total_count,
                    ev_split)
        return max(cur_ev, ev_draw/total_count)


class Timer(Thread):
    '''Basic timer used to control runwild execution time'''

    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0
        self.hastorun = True

    def run(self):
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, self.done))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1


def cls():
    '''Simple screen clear function'''
    print('\n')
    os.system('cls' if os.name == 'nt' else 'clear')


def score(cards):
    '''fonction giving hand score and managing aces value'''
    toreturn = sum(cards) + len(cards)
    if cards in ([0, 9], [9, 0]):
        return 0
    return toreturn + 10 if (cards.count(0) and toreturn < 12) else toreturn


def eval_dealer(deck, dcard):
    '''function returning dealer's scores probability distribution'''
    ddib = []
    for index in _R6:
        sco = 0.
        for deep, endnodes in enumerate(_GRAPHS[dcard][index]):
            tosum = 0
            for endnode in endnodes:
                cards = endnode[:-1]
                tomult = endnode[-1]
                for card, count in cards:
                    if count:
                        tomult *= _PRECALC[count - 1][deck[card]]
                tosum += tomult
            sco += tosum / _PRECALC2[sum(deck)][deep]
        ddib.append(sco)
    return ddib + [1 - sum(ddib)]


def evd(sco, ddib, splits):
    '''function returning player's expval against a scores distribution'''
    if sco > 21:
        return 0
    if sco == 0:
        if splits:
            return 1 - ddib[5]
        else:
            return 1.5 * (1 - ddib[5])
    toreturn = ddib[6] - ddib[5]
    index = max([sco - 17, -1])
    toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
    return toreturn
    