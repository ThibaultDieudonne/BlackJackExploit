# test double up, test split (cas aces)
# ameliorer eval_dealer 
# implementer run all cases + affichage secondes/percentage
import os
import sys
import time
import random
from threading import Thread
class Game():
    def __init__(self, iters, card1 = 0, card2 = 0, dcard = 0):
        self.record = 0.
        self.iters = iters
        self.done = 0
        self.taskdone = False
        self.card1 = card1
        self.card2 = card2
        self.dcard = dcard
    def play(self):
        for iter in range(self.iters):
            self.evds = []
            self.hands = []
            deck = Deck()
            if self.dcard:
                self.pcards = [deck.pick(self.card1), deck.pick(self.card2)]
                self.dcards = [deck.pick(self.dcard)]
            else:
                self.pcards = [deck.draw(), deck.draw()]
                self.dcards = [deck.draw()]
            self.ddib = self.eval_dealer(deck.cards)
            score = self.score(self.pcards)
            if not score:
                self.record += 1.5 * (1 - self.ddib[5])
            else:
                self.record += self.ev(self.pcards, deck.cards, self.evd(score, self.ddib))
            self.done += 1
            if not iter % 50:
                if iter:
                    cls()
                    print("{} iterations done ({}%)".format(iter, round(float(iter)/self.iters,4)*100))
                    print("Elapsed time: {}s".format(timer.count))
                    print("Current average EV = {}%".format(round(100 * self.record / self.done, 2)))
        self.taskdone = True
        
    def eval_dealer(self, deck):
        self.edreturn = [0] * 7
        self.e_d_rec(self.dcards, deck)
        return [_ for _ in self.edreturn]
        
    def e_d_rec(self, dhand, deck, prob = 1.):
        score = self.score(dhand)
        if score > 16 or not score:
            if score == 0:
                self.edreturn[5] += prob
            elif score < 22:
                self.edreturn[score - 17] += prob
            else:
                self.edreturn[6] += prob
        else:
            for value, count in enumerate(deck):
                if count:
                    ndeck = [_ for _ in deck]
                    ndeck[value] -= 1
                    nhand = dhand + [value]
                    self.e_d_rec(nhand, ndeck, prob * count / (sum(deck)))
        return None
        
    def score(self, cards):
        nbAces = cards.count(0)
        toreturn = sum(cards) + len(cards)
        if cards == [0, 9] or cards == [9, 0]:
            return 0
        return toreturn + 10 if (nbAces and toreturn < 12) else toreturn

    def evd(self, score, ddib):
        if score > 21:
            return 0
        if score == 0:
            return 1.5*(1 - ddib[5])
        toreturn = ddib[6] - ddib[5]
        index = max([score - 17, -1])
        toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
        return toreturn

    def ev(self, phand, deck, cur_ev):
        ev_draw = 0
        tcount = float(sum(deck))
        for value, count in enumerate(deck):
            if count:
                nhand = sorted(phand + [value])
                lhand = len(nhand)
                strhand = ''.join(map(str, nhand)).zfill(lhand)
                try:
                    ev_draw += count * self.evds[lhand - 1][self.hands[lhand - 1].index(strhand)]
                except:
                    score = self.score(nhand)
                    if score > 21:
                        ev_draw -= count
                    else:
                        ndeck = [_ for _ in deck]
                        ndeck[value] -= 1
                        tmp_ev = self.evd(score, self.eval_dealer(ndeck))
                        if sum(nhand) + len(nhand) != score or score < 18:
                            tmp_ev = max([tmp_ev, self.ev(nhand, ndeck, tmp_ev)])
                        ev_draw += count * tmp_ev
                        while len(self.hands) < lhand:
                            self.hands.append([])
                            self.evds.append([])
                        self.hands[lhand - 1].append(strhand)
                        self.evds[lhand -1].append(tmp_ev)
        return max(cur_ev, ev_draw/(tcount))
    
class Deck:
    def __init__(self):
        self.NBDECKS = 8
        self.cards = [4 * self.NBDECKS] * 9 + [16 * self.NBDECKS]

    def draw(self):
        a = random.randint(0,sum(self.cards))
        for i in range(10):
            if sum(self.cards[:i+1]) >= a:
                self.cards[i] -= 1
                return i
    
    def pick(self, value):
        self.cards[value - 1] -= 1
        return value - 1

class Timer(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.count = 0.
        self.hastorun = True
    def run(self):
        while self.hastorun:
            time.sleep(.2)
            self.count += .2
def cls():
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')

def runwild(iters):
    globals()['timer'] = Timer()
    timer.is_daemon = True
    timer.start()
    game = Game(iters, 1, 2, 1)
    print('Running ...')
    game.play()
    cls()
    print("{} iterations done in {}s\nAverage EV = {}%".format(iters, timer.count, round(100 * game.record / iters, 6)))

def run(card1, card2, dcard):
    cardnames = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T']
    game = Game(1, card1, card2, dcard)
    game.play()
    cls()
    print("{}{} vs {}".format(cardnames[game.pcards[0]], cardnames[game.pcards[1]], cardnames[game.dcards[0]]))
    print("EV = {}".format(game.record))

try:
    runwild(int(sys.argv[1]))
except:
    runwild(1)
    #run(10,1,10)