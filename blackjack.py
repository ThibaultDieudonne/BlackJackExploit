import os
import time
from threading import Thread

from load_static import _GRAPHS, _PRECALC, _PRECALC2, _R6
    
class FastEval():
    
    '''handle solving with memory for efficiency'''
    
    __slots__ = ['evs',
                'hs',
                'ddib',
                'hds',
                'evsd',
                'cards',
                'dcard',
                'deck',
                'depth',
                'ps',
                'isize']
                    
    
    def __init__(self, cards, deck, after_dealt, depth, ps = False, isize = 0):
        '''class inits'''
        self.depth = depth
        self.ps = ps
        self.isize = isize
        self.dcard = cards[-1]
        self.cards = cards[:-1]
        self.deck = [_ for _ in deck]
        if not after_dealt:
            for card in cards:
                self.deck[card] -= 1
        self.hs = [[]for _ in range(16)] # saved hands
        self.evs = [[]for _ in range(16)] # saved ev
        self.hds = [] # saved doubled hands
        self.evsd = [] # saved double ev
        self.ddib = eval_dealer(self.deck, self.dcard)

    def ev(self, phand, deck, cur_ev, splits = 0):
        '''recursive function evaluating player's ev for each possible action'''
        ev_draw = 0
        lh = len(phand) + 1
        total_count = float(sum(deck))
        if lh == 3:
            ev_double = 0
            ev_split = -2
            if phand[0] == phand[1] and not splits:
            #and ((splits == 1 and phand[0]) or not splits): => resplit EV
                calc_split = FastEval(
                    [phand[0],
                    self.dcard],
                    deck,
                    True,
                    self.depth)
                ev_split = 2 * calc_split.ev(
                    [phand[0]],
                    calc_split.deck,
                    evd(score(calc_split.cards), calc_split.ddib, 1),
                    splits + 1)
        for value, count in enumerate(deck):
            # evaluating new score
            nh = phand + [value]
            sco = score(nh)
            ndeck = [_ for _ in deck]
            ndeck[value] -= 1
            # handle 'too many' 
            if sco > 21:
                ev_draw -= count
                if lh == 3:
                    ev_double -= count
            else:
                sh = sorted(nh[1:])
                # access ev if stored 
                try:
                    ev_draw += count * self.evs[lh-1][self.hs[lh-1].index(sh)]
                    if lh == 3:
                        ev_double += count * self.evsd[self.hds.index(sh)]
                except:
                    # calculationg dealer's scores probability distribution
                    if lh < self.depth:
                        self.ddib = eval_dealer(ndeck, self.dcard)
                    # calculating ev
                    tmp_ev = evd(sco, self.ddib, splits)
                    # saving ev of two cards hs in order to access in evsd later
                    if lh == 3:
                        ev_double += count * tmp_ev
                        self.hds.append(sh)
                        self.evsd.append(tmp_ev)
                    # going recursive
                    subcond = (sco < 19 and sco) or (lh == 2 and nh[0] == nh[1])
                    if subcond and (not splits or phand[0]):
                        tmp_ev = max([
                            tmp_ev,
                            self.ev(nh, ndeck, tmp_ev, splits)])
                    # weigting found ev
                    ev_draw += count * tmp_ev
                    # saving result
                    if lh > 2:
                        self.hs[lh - 1].append(sh)
                        self.evs[lh - 1].append(tmp_ev)
        # dictionnary return for playsingle
        if self.ps and lh == self.isize and not splits:
            toreturn = {'Stand': cur_ev, 'Hit': ev_draw/total_count}
            if lh == 3:
                toreturn['Double'] = 2 * ev_double/total_count
                if ev_split != -2:
                    toreturn['Split'] = ev_split
            return toreturn
        # returning best ev
        if lh == 3:
            if splits:
                return max(cur_ev, ev_draw/total_count, ev_split)
            else:
                return max(
                    cur_ev,
                    ev_draw/total_count,
                    2 * ev_double/total_count,
                    ev_split)
        return max(cur_ev, ev_draw/total_count)
            

class Timer(Thread):
    '''Basic timer used to control runwild execution time'''
    def __init__(self):
        Thread.__init__(self)
        self.count = 0
        self.done = 0
        self.hastorun = True
    def run(self):
        while self.hastorun:
            cls()
            try:
                print('Running for {}s ({}%)'.format(self.count, self.done))
            except:
                print('Starting ...')
            time.sleep(1)
            self.count += 1

def cls():
    '''Simple screen clear function'''
    print('\n')
    os.system('cls' if os.name=='nt' else 'clear')
          
def score(cards):
    '''fonction giving hand score and managing aces value'''
    nbAces = cards.count(0)
    toreturn = sum(cards) + len(cards)
    if cards == [0, 9] or cards == [9, 0]:
        return 0
    return toreturn + 10 if (nbAces and toreturn < 12) else toreturn
    
def eval_dealer(deck, dcard):
    '''function returning dealer's scores probability distribution'''
    ddib = []
    for index in _R6:
        sco = 0.
        for deep, endnodes in enumerate(_GRAPHS[dcard][index]):
            tosum = 0
            for endnode in endnodes:
                cards = endnode[:-1]
                tomult = endnode[-1]
                for card, count in cards:
                    if count:
                        tomult *= _PRECALC[count - 1][deck[card]] 
                tosum += tomult
            sco += tosum / _PRECALC2[sum(deck)][deep]
        ddib.append(sco)
    return ddib + [1 - sum(ddib)]
        
def evd(sco, ddib, splits):
    '''function returning player's ev against a scores distribution'''
    if sco > 21:
        return 0
    if sco == 0:
        if splits:
            return 1 - ddib[5]
        else:
            return 1.5 * (1 - ddib[5])
    toreturn = ddib[6] - ddib[5]
    index = max([sco - 17, -1])
    toreturn += sum(ddib[:index if index != -1 else 0]) - sum(ddib[index+1:5])
    return toreturn
