# test double up, test split (cas aces)
from copy import deepcopy
import random


class Game():
    def __init__(self):
        self.record = []

    def play(self):
        deck = Deck()
        # pcards = [deck.draw(), deck.draw()]
        # dcards = [deck.draw()]
        pcards = [deck.pick(3), deck.pick(7)]
        dcards = [deck.pick(6)]
        self.ddib = self.eval_dealer(dcards, deck.cards, [0] * 7, 1.)
        self.localEV = self.evd(self.score(pcards), self.ddib)
        print dcards, pcards
        print [round(i, 4) for i in self.ddib]
        print self.localEV

    def eval_dealer(self, hand, deck, toreturn, prob):
        score = self.score(hand)
        if score > 16 or not score:
            if score == 0:
                toreturn[5] += prob
            elif score < 22:
                toreturn[score - 17] += prob
            else:
                toreturn[6] += prob
        else:
            for value, count in enumerate(deck):
                if count:
                    ndeck = [_ for _ in deck]
                    ndeck[value] -= 1
                    nhand = hand + [value]
                    toreturn = self.eval_dealer(nhand, ndeck, toreturn, prob * count / (sum(ndeck) + 1))
        return toreturn

    @staticmethod
    def score(cards):
        nbAces = cards.count(0)
        res = sum(cards) + len(cards) + nbAces * 10
        if res == 21 and len(cards) == 2:
            return 0
        for _ in range(nbAces):
            if res > 21:
                res -= 10
        return res

    @staticmethod
    def isflex(cards):
        if sum(cards) + len(cards) < Game.score(cards):
            return True

    def evd(self, score, evD):
        if score > 21:
            return 0
        if score == 0:
            return 1.5 * (1 - evD[5])
        res = evD[6] - evD[5]
        for i in range(5):
            if score > i + 17:
                res += evD[i]
            elif score < i + 17:
                res -= evD[i]
        return res


class Deck:
    def __init__(self):
        self.NBDECKS = 8
        self.cards = [4 * self.NBDECKS] * 9 + [16 * self.NBDECKS]

    def draw(self):
        a = random.randint(0, sum(self.cards))
        for i in range(10):
            if sum(self.cards[:i + 1]) >= a:
                self.cards[i] -= 1
                return i

    def pick(self, value):
        self.cards[value] -= 1
        return value


game = Game()
game.play()
